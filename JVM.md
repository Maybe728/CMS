#JVM
   1.GC流程
    
    
        1.当现在有一个新的对象产生，那么对象一定需要内存空间，于是现在就需要为该对象进行内存空间的申请；
        
        2.首先会判断伊甸园区是否有内存空间，如果此时有内存空间，则直接将新对象保存在伊甸园区；
        
        3.但是如果此时伊甸园区的内存空间不足，那么会自动执行一个MinorGC操作，
 
          将伊甸园区的无用内存空间进行清理，清理之后会继续判断伊甸园区的内存空间是否充足？
          
          如果内存空间充足，则将新的对象直接在伊甸园区进行空间分配；
          
        4.如果执行了Minor GC之后发现伊甸园区的内存依然不足，那么这个时候会进行存活区判断，
        
          如果存活区有剩余空间，则将伊甸园区的部分活跃对象保存在存活区，
          
          那么随后继续判断伊甸园区的内存空间是否充足，如果充足，则在伊甸园区进行新对象的空间分配；
          
        5.如果此时存活区也已经没有内存空间了，则继续判断老年区，如果此时老年区空间充足，
        
          则将存活区中的活跃对象保存到老年代，而后存活区就会存现有空余空间，
          
          随后伊甸园区将活跃对象保存在存活区之中，而后在伊甸园区里为新对象开辟空间；
          
        6.如果这个时候老年代也满了，那么这个时候将产生M ajor GC（FullGC），进行老年代的内存清理。
        
        7.如果老年代执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”;
        
   2.问题：“StackOverflowError”和“OutOfMemoryError”的区别是什么？
    
        StackOverflowError：
        每当java程序启动一个新的线程时，java虚拟机会为他分配一个栈，java栈以帧为单位保持线程运行状态；
        当线程调用一个方法是，jvm压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个栈帧就存在。 
        如果方法的嵌套调用层次太多(如递归调用),随着java栈中的帧的增多，最终导致这个线程的栈中的
        所有栈帧的大小的总和大于-Xss设置的值，而产生生StackOverflowError溢出异常。
        
        OutOfMemoryError：
        因为内存溢出,JVM不能分配给对象的创建空间.并且GC也不能够回收足够的空间.
        当你创建对象的速度快于JVM回收空间的时候就会发生空间不足这个问题
        
        栈内存溢出
        
        java程序启动一个新线程时，没有足够的空间为改线程分配java栈，一个线程java栈的大小由-Xss设置决定；
        JVM则抛出OutOfMemoryError异常。
        
        堆内存溢出
        
        java堆用于存放对象的实例，当需要为对象的实例分配内存时，而堆的占用已经达到了设置的最大值(通过-Xmx)设置最大值，
        则抛出OutOfMemoryError异常。
        
        方法区内存溢出
        
        方法区用于存放java类的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。
        在类加载器加载class文件到内存中的时候，JVM会提取其中的类信息，并将这些类信息放到方法区中。 
        当需要存储这些类信息，而方法区的内存占用又已经达到最大值（通过-XX:MaxPermSize）；
        将会抛出OutOfMemoryError异常对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，
        直到溢出。这里需要借助CGLib直接操作字节码运行时，生成了大量的动态类。
        
   3.     
    
    